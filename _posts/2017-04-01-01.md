---
layout: post
title: "一些JS方法"
date: 2017-04-01
description: "一些JS方法"
tag: 博客 
---   

### JavaScript instanceof 运算符代码
```html
//L 表示左表达式，R 表示右表达式
function instance_of(L,R) { 
    var O = R.prototype; // 取R的显示原型
    L = L.__proto__; // 取L的隐式原型
    while(true) {
        if (L === null) {
            return false
        }
        // R.prototype === L.__proto__
        if (O === L) { // 这里重点：当 O 严格等于 L 时，返回 true  
            return true;
        }
        L = L.__proto__; 
    }
}
```    

### on(注册一个事件)    
```html
Event.prototype.on = function (type, fun) {
    let cbs = this._events[type];
    cbs ? cbs.push(fun) : this._events[type] = [];
    if(!cbs) {
        this._events[type].push(fun)
    }
}
```    
这里为什么要将this._events设计为二维数组？因为事件可以是多个,但是事件名可能相同。   
这个逻辑意图非常明显,根据type参数从this._events中获取是否存在。如果不存在,创建一个type为key的数组,并将事件句柄程序push到数组中。

### off(注销一个事件)    
```html
Event.prototype.off = function (type, fun) {
    let cbs = this._events[type];
    // 事件队列中无事件
    if (!cbs) {
        return this;
    }
    // 删除所有的事件
    if (!type && !fun) {
        this._events = {};
        return this;
    }
    // 只有事件名称时
    if (type && !fun) {
        this._events[type] = null;
        return this;
    }
    // 删除某个事件队列中的某个事件
    let cb;
    let i = cbs.length;
    while (i--) {
        cb = cbs[i];
        if (cb === fun || cb.fun === fun) {
            cbs.splice(i, 1);
            break;
        }
    }
};
```    
虽然注销事件方法的逻辑可能相比下稍许多了些,但它的实现也非常简单,只要只存在事件组key名的情况,或者删除某个事件队列中的某个事件句柄程序即可

### emit(触发一个事件)   
```html
Event.prototype.emit = function(type){
    let cbs = this._events[type];
    let args = tools.toArray(arguments,1);
    if (cbs) {
        let i = 0;
        let j = cbs.length;
        for(;i<j;i++){
            let cb = cbs[i];
            cb.apply(this,args);
        }
    }
}
```     
这里通过事件名从this._events获取相应的事件句柄程序数组,然后将arguments转成数组,(这里考虑是可能会传入参数)如果事件句柄程序数组存在,进行循环,再将args参数apply给每一个取出来的事件句柄程序。    


### 实现一个clon,对js中的5种主要数据类型镜像复制

```html
function clone (obj) {
    var o;
    switch (typeof obj) {
        case "undefined":
            break;
        case "string":
            o = obj + "";
            break;
        case "number":
            o = obj - 0;
            break;
        case "boolean":
            o = obj;
            break;
        case "object": // object分为两种情况一种是对象 一种是数组
            if (obj === null) {
                o = null;
            }
            else {
                if (Object.prototype.toString.call(obj).slice(8, -1) === "Array") {
                    o = [];
                    for (var i = 0; i < obj.length; i++) {
                        o.push(clone(obj[i]));
                    }
                }
                else {
                    o = {};
                    for (var k in obj) {
                        o[k] = clone(obj[k]);
                    }
                }

            }

    }
    return o;
}
```    

### 消除一个数组里面重复的元素
```html
var arr1 = [1, 2, 2, 2, 3, 3, 3, 4, 5, 6];
var arr2 = [];
for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) < 0) { // 如果要检索的字符串值没有出现
        arr2.push(arr1[i]) // push进入数组
    }
}
console.log(arr2); // [1, 2, 3, 4, 5, 6]
```     
### 消除字符串前后空格
```html
function trim (str) {
    if (str && typeof str === 'string') {
        return str.replace(/(^\s*)|(\s*$)/g, ''); //去除前后空白符
    }
}

var str = '             ab             ';
console.log(trim(str)); // ab
```    

### 求一个字符串的字节长度   
```html
function GetBytes (str) {
    var len = str.length;
    var bytes = len;
    for (var i = 0; i < len; i++) {
        if (str.charCodeAt(i) > 255) {
            bytes++;
        }
    }
    return bytes
}

```

### 简单实现 Function.bind 函数
```html
if (!function() {}.bind) {
    Function.prototype.bind = function(context) {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        return function() {
            return self.apply(context, args.slice(1));
        }
    };
}
```