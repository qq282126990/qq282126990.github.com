---
layout: post
title: "一些小笔记"
date: 2017-04-01
description: "一些小笔记"
tag: 博客 
---   

js中__proto__和prototype的区别和关系？   

**__proto__**(隐式原型)与**prototype**(显式原型)     
  
### 简介
- **显示原型prototype**

每一个函数在创建之后都会拥有一个名为prototype的属性,这个属性执行函数的原型对象。     
注意：通过Function.prototype.bind方法构造出来的函数是个例外,它没有prototype属性。    

- **隐式原型__proto__**     

JavaScript中任意对象都有一个内置属性[[prototype]],在ES5之前没有标准的方法访问这个内置属性,但是大多数浏览器都支持通过__proto__来方法。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf();     
注意：Object.prototype这个对象是一个例外,它的__proto__值为null。     

- **两者的关系**    
隐式原型指向**创建**这个对象的函数(constructor)的prototype

### 作用
- 显示原型(prototype)的作用： 用来实现基于原型的继承与属性的共享
> ECMAScript不使用C++,Smalltalk和Java中的类。
> 相反,可以通过各种方式创建对象,包括通过文字符号或通过创建对象的构造函数,
> 然后执行通过为其属性分配初始值来初始化全部或部分对象的代码。
> 每个构造函数都有一个名为"prototype"的属性,用于实现基于原型的继承和共享属性。   
> 通过在新表达式中使用构造函数来创建对象,例如：new Date(2009,11) 创建一个新的日期对象。   

- 隐式原型的作用：构成原型链,同样用于实现基于原型继承。例如：当我们访问obj这个对象中的name属性时,如果在obj中找不到,那么就会沿着__proto__依次查找。
> 由构造函数创建的每个对象都有一个隐式引用(称为对象的原型)到其构造函数的"原型的值"

### __proto__的指向
__proto__的指向到底如何判断？    
根据ECMA定义'to the value of its constructor’s "prototype" '----指向创建这个对象的函数的显式原型。关键点在于找到创建这个对象的构造函数,接下来就来看一下js中对象被创建的方法。
   
一眼看过去似乎有三种方式：   
(1)对象字面量的方式   
(2)new 的方法   
(3)ES5中的Object.create()      

但是我认为本质上只有一种方式，也就是通过new来创建。
首先字面量的方式是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy;     
再来看看Object.create(),这是ES5中新增的方法，在这之前这被称为原型式继承。

例子：借助原型可以基于已有的对象创建新对象   
```html
function object(o){
    function F(){}
    F.prototype = o;
    return new F()
}
```   
所以从实现代码 return new F()中我们可以看到,这依然是通过new来创建的。     
不同之处在于由Object.create()创建出来的对象没有构造函数,看到这里你是不是要问,没有构造函数我怎么知道它的__proto__指向哪里呢,     
其实这里说它没有构造函数是指在 Object.create()函数外部我们不能访问到它的构造函数,然而在函数内部实现中是有的,它短暂地存在了那么一会儿。   
假设我们现在就在函数内部，可以看到对象的构造函数是F, 现在
```html
// 以下是用于验证的代码
var f = new F();
// 于是有
f.__proto__ === F.prototype // true
// 又因为
F.prototype === o // true
// 所以
f.__proto__ === o; // true
```
因此由Object.create(o)创建出来的对象它的隐式原型指向o。好了，对象的创建方式分析完了，现在你应该能够判断一个对象的__proto__指向谁了。

好吧，还是举一些一眼看过去比较疑惑的例子来巩固一下。
- 构造函数的显示原型的隐式原型     
1.内建对象：比如Array(),Array.prototype.__proto__指向什么？
Array.prototype也是一个对象,对象就是由Object()这个构造函数创建的。     
因此Array.prototype.__proto__ === Object.prototype // true,   
或者或者也可以这么理解，所有的内建对象都是由Object()创建而来。    

- 自定义对象    

**1.默认情况下：**
```html
function Foo(){
    var foo = new Foo();
    Foo.prototype.__proto__ === Object.prototype // true 所有的内建对象都是由Object()创建而来
}
```   
**2.其他情况：**      
(1)
```html
function Bar() {}
// 这时我们想让Foo继承Bar
Foo.prototype = new Bar;
Foo.prototype.__proto__ === Bar.prototype // true
```   
(2)   
```html
//我们不想让Foo继承谁，但是我们要自己重新定义Foo.prototype
Foo.prototype = {
  a:10,
  b:-10
}
//这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 
Foo.prototype.__proto__ === Object.prototype 
```   
注：以上两种情况都等于完全重写了Foo.prototype，所以Foo.prototype.constructor也跟着改变了，于是乎constructor这个属性和原来的构造函数Foo（）也就切断了联系。

- 构造函数的隐式原型    
既然是构造函数那么它就是Function()的实例,因此也就是指向Function.prototype,比如Object.__proto__ === Function.prototype    
